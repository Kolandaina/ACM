# A 私人笑声

本题考察C++语法，需要使用 ：
```
	std::string s;
	std::getline(std::cin, s);
```
读入带有空格的字符串，然后遍历一边字符串每当出现字符 '.' 则额外输出字符串 "xixixixi." 即可。

# L 加纳~

已知视频一共完整播放了 k / n 遍，然后我们需要判断一下剩下的时间是否大于 m 秒即可。

# J 最后都是0

本题其实是一个非常简单的DP，设整数 n 的某一位上的数为 j 则：
$$
f[n] = inf\\
f[n] = min(f[n], f[n - j] + 1)
$$
然后递推求解就可以得到最终的答案了。
本题也可以采用bfs的方法。

# G 相加余三（easy）

本题分别模拟三种情况然后取最大值即可。

# B 孵化小鸡

由于本题的数据范围非常小，我们可以用dfs或者二进制枚举的方法找到所有的方案，然后去判断每个方案是否满足条件，最后输出满足条件的方案数即可。

# D 划分田地（easy）

与B题非常相似，我们只需要去判断包含了每一种子集中的土豆的最小矩形中的土豆数量是否等于该子集中的土豆数量即可。这里用到了二维前缀和来维护某一个矩形中的土豆数量。

# K 第五人格，启动！

BFS模板题，我们可以在BFS外面套用一个全排列函数来表示每一种操作顺序，最后取能满足条件的最短时间即可。

# I 找除数

设一个正整数 n ，该可以表示为：
$$
n = p_1^{x_1}*p_2^{x_2}*……*p_n^{x_n};
其中p_i为素数，n的除数的数量 = (x_1 + 1) * (x_2 + 1) *……* (x_n + 1);
$$

# H 相加余三（hard）

本题考查区间DP：
$$
设f[i][j]为区间[l, r]的最大贡献值, 下标从1开始\\
当：l >= r 时f[i][j] = 0;
否则：f[i][j] = max((a[l] + a[l + 1]) \% 3 + f[i + 2][r],\\
(a[r] + a[r - 1]) \% 3 + f[i][r - 2],\\
(a[l] + a[r]) \% 3 + f[i + 1][r - 1])。
$$
由于某一个区间可能会被多次访问，我们需要使用记忆化搜索的方式来优化。

# F 加一余二

本题可以使用set去存放每个不同的区间，使用multiset存放每个相同区间的长度。
每次反转则改变相邻的两个区间即可，然后更新multiset中的区间长度，每次查询输出最大的区间长度即可。


