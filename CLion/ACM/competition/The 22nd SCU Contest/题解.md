# L 道路

最小化极差就是最小化最大值减最小值的差。

如果要最小化最大值：每一轮走深度最小的叶子总是最优。

如果要最大化最小值：优先把深度最小的叶子走了还是最优。

可以证明一种最优解就是按深度从小到大走叶子。

# I Mai 语言

显然，可以让构造的文件的第 $i$ 行为 $2^i$ 。让分母变大只会让答案变劣。

如果需要增加 $1$ 的节拍，可以从当前 $x$ 最小的行尝试添加，直到这一行被加满了，如果还需要添加 $t$ 个逗号，那么尝试在下一行加入 $2t$ 个逗号。

构造完成后从上往下扫一次所有行，将逗号展开到下面空的行即可。

一些 corner cases:

- 如果 $n=1$ ，只可能在一行内添加逗号，因此 $x = 1$ ，要和其他情况做出区分。

- 如果 $k = 1$ ，不能添加 $2^0$ ，但是可能存在解，可以用 $x = 2,4,8,\ldots$ 。

# H 数 01 串

定义连续段为极长的连续字符。

每个 $1$ 操作会恰好新增两个连续段，每个 $2$ 操作不会影响连续段的数量。

结论：设 $S$ 的连续段数是 $s$ ，在 $S$ 串中使用 $a$ 次 $1$ 操作和 $b$ 次 $2$ 操作可以得到 $T$ 的充要条件是 $T$ 的连续段数是 $s + 2a$ 、$T$ 的长度是 $|S| + a + b$ 且 $S$ 除去第一个字符的串是 $T$ 除去第一个字符的串的子序列。

即计数满足这几个条件的串 $T$ 的数量。对于每一个 $T$ 有一个 $S$ 的唯一贪心子序列匹配。计数 $T$ 的数量即计数有多少不同的贪心子序列匹配方法。

可以发现 $1$ 操作可以分为两类，一种是在贪心匹配结尾后面新增的段，一种是在结尾前面匹配的段。

设串中有 $s$ 个相邻且连续的字符，那么枚举有多少 $1$ 操作在贪心匹配中的相邻连续的位置添加字符，剩余的操作在结尾添加段。

对于 $2$ 操作，本质上就是把数分配到一些连续段中，这个方案是一个插板法。省略细节推导，最终式子是：
$$
\sum _{i=0}^a \binom s i \binom{b + n - s + 1 }{n - s + 2a - i - 1}
$$
