
这是问题的简单版本。在这个版本中 $1 \le n, m \le 100$ 。只有解决并锁定这两个问题，才能破解这个问题。

给你一个长度为 $n$ 的整数序列 $a=[a_1,a_2,\dots,a_n]$ 。从序列 $a$ 中移除零个或多个元素，即可得到它的子序列（它们不一定连续）。例如，对于序列 $a=[11,20,11,33,11,20,11]$ ：

- $[11,20,11,33,11,20,11]$ 、 $[11,20,11,33,11,20]$ 、 $[11,11,11,11]$ 、 $[20]$ 、 $[33,20]$ 是子序列（这些只是长列表中的一部分）；
- $[40]$ 、 $[33,33]$ 、 $[33,20,20]$ 、 $[20,20,11,11]$ 不是子序列。

假设再给出一个非负整数 $k$ ( $1 \le k \le n$ )，那么在下列情况下，这个子序列称为最优序列：

- 它的长度为 $k$ ，且其元素之和是所有长度为 $k$ 的子序列中的最大值；
- 在所有长度为 $k$ 的子序列中，满足前一项的子序列在词法上是最小的。

回顾一下，如果序列 $b=[b_1, b_2, \dots, b_k]$ 与序列 $c=[c_1, c_2, \dots, c_k]$ 的第一个元素（从左起）在序列 $b$ 中的差异小于在 $c$ 中的差异，那么序列 $b=[b_1, b_2, \dots, b_k]$ 在词法上小于序列 $c=[c_1, c_2, \dots, c_k]$ 。形式上：存在 $t$ （ $1 \le t \le k$ ）。( $1 \le t \le k$ )，使得 $b_1=c_1$ ， $b_2=c_2$ ，...， $b_{t-1}=c_{t-1}$ 同时 $b_t&lt;c_t$ 。例如

- $[10, 20, 20]$ 的词性小于 $[10, 21, 1]$ 、
- $[7, 99, 99]$ 在词法上小于 $[10, 21, 1]$ 、
- $[10, 21, 0]$ 的词性小于 $[10, 21, 1]$ 。

给您一个 $a=[a_1,a_2,\dots,a_n]$ 和 $m$ 的请求序列，每个请求由两个数字 $k_j$ 和 $pos_j$ （ $1 \le k \le n$ ， $1 \le pos_j \le k_j$ ）组成。对于每个查询，打印给定序列 $a$ 的最优子序列 $pos_j$ 中的值 $k=k_j$ 。

例如，如果 $n=4$ ， $a=[10,20,30,20]$ ， $k_j=2$ ，那么最优子序列就是 $[20,30]$ --它是所有长度为 $2$ 的子序列中最小的词序，且总项数最多。因此，请求 $k_j=2$ , $pos_j=1$ 的答案是数字 $20$ ，请求 $k_j=2$ , $pos_j=2$ 的答案是数字 $30$ 。
