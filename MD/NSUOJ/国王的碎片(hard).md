# 国王的碎片（hard）

# 题目描述

在一个遥远的王国里，国王正面临一项艰巨的任务。这个王国世代以来依靠一块神圣石碑的庇佑，这块石碑蕴含着强大的神秘力量，保护着整个王国免受外敌侵袭。然而，不久前，一个恶魔趁着夜色突袭，摧毁了这块神圣石碑，将它打碎成了 $n$ 块。每一块碎片都蕴含着一种神秘的能量，这些能量共有$m$种不同的类型。石碑的破碎让王国陷入了前所未有的危机，各地的灾祸频繁，百姓们生活在恐惧之中。为了重铸石碑，恢复王国的安宁，国王需要召集一支小队，从这些散落的碎片中选取一段**连续**的碎片，使得这段碎片中恰好包含特定数量的每种能量，然而国王发现并不是每次都可以选择连续的这些碎片，因为其中一些碎片有瑕疵，所以国王决定从这段连续的碎片中丢掉一些碎片。

具体而言，国王需要找到一段连续的碎片，使得其中包含第$1$种能量的碎片有$k_1$块，第$2$种能量的碎片有$k_2$块，以此类推，第$m$种能量的碎片有$k_m$块。每种能量都代表着王国的一部分力量，比如勇气、智慧、力量、仁爱等等，这些力量的平衡与和谐是石碑力量的源泉。国王深知，如果不能在最短的时间内找到这些碎片并重新拼接好石碑，整个王国将陷入更深的混乱，甚至有可能彻底覆灭。为了找到这一段完美匹配条件的碎片，国王发布了紧急命令，希望王国中最聪明、最勇敢的人们能够挺身而出，帮助他完成这项艰巨的任务。

国王的顾问们已经对碎片进行了分类和编号，但他们需要更精确的帮助来找到这一段**连续**的碎片。时间紧迫，恶魔的阴影已经开始笼罩王国，危机四伏。每当夜晚降临，恶魔的力量就会增强，带来更多的混乱和破坏，迫使百姓们不得不生活在恐惧之中。勇敢的战士们，王国的未来掌握在你们手中，能否帮助国王找到答案，拯救这个美丽的王国？找到这些碎片不仅仅是对智慧和勇气的考验，更是对忠诚和信仰的证明。每一个成功的尝试都将为王国带来希望，而每一次失败都会让王国离毁灭更近一步。你准备好迎接这个挑战了吗？

$hard$与$easy$的区别在于$hard$可以在序列中丢弃一些数来重新匹配。

# 输入格式

第一行输入一个整数$T$代表输入数据组数，接下来的每三行为一组输入。

第$i+1$行包含两个整数 $n$($1 \le n \le 2·10^{5}$）和 $m$（$1 \le m \le n$），表示碎片的数量和能量类型的种类数。

第$i+2$行包含 $n$ 个整数，范围在 $1$ 至 $m$ 之间，表示每个碎片所蕴含的能量类型。

第$i+3$行包含 $m$ 个整数 $k_1,k_2,...,k_m$（$\displaystyle 1 \le \sum_{i = 1}^{m} k_i \le n$），表示每种能量类型所需的碎片数量。

# 输出格式

输出一共$T$行，每行输出一个数字：表示需要从序列中移除的碎片的最小数量，以便在剩余的序列中，能够与$k_i$相匹配。如果无法实现，则输出- 1

### 样例输入

```
8 3
3 3 1 2 2 1 1 3
3 1 1
```

### 样例输出

```
1
```

对于 $3,3,1,2,2,1,1,3$ ，我们选取连续段$1,2,2,1,1,3$ 后，只要删除一个$2$，即可满足——$1$有$3$个，$2$有$1$个，$3$有$1$个。

# 题解

---

运用尺取法，设$𝑙$为左界，$𝑟$为右界，若$𝑐[𝑎[𝑟]]=𝑏[𝑎[𝑟]]$则说明对$𝑏$中第$𝑎[𝑟]$个数字的个数要求达到满足，则$cnt$+1。如果 $𝑠𝑢𝑚=𝑚$，则说明该子串满足条件，那么我们就要将左界前进（为了使删除的数字更少，最后 $𝑟−𝑙+1$肯定是最小的），此处注意要使 $𝑐[𝑎[𝑙]]$，如果它在减之前的个数等于 $𝑏[𝑎[𝑙]]$ 则说明删减后，满足条件的个数减 1，即 $cnt−1$。

---

```C++
#include <bits/stdc++.h>
#define int long long
#define endl "\n"
#define fs(x) std::fixed << std::setprecision(x)
const int N = 2e5 + 10;
const int mod = 1e9 + 7;
const int INF = INT64_MAX;
inline void slove()
{
    int n, m;
    std::cin >> n >> m;
    std::vector<int> a(n), k(m + 1), c(m + 1);
    int sum = 0, ans = INF, cnt = 0;
    for (int i = 0; i < n; i++) std::cin >> a[i];
    for (int i = 1; i <= m; i++)
    {
        std::cin >> k[i];
        if (k[i] == 0) cnt++;
        sum += k[i];
    }
    int l = 0;
    for (int r = 0; r < n; r++)
    {
        c[a[r]]++;
        if (c[a[r]] == k[a[r]]) cnt++;
        while (cnt == m)
        {
            ans = std::min(ans, r - l + 1 - sum);
            if (c[a[l]] == k[a[l]]) cnt--;
            c[a[l]]--;
            l++;
            if (cnt < m) break;
        }
    }
    std::cout << (ans == INF ? -1 : ans);
}
signed main()
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int t = 1;
    std::cin >> t;
    while (t--) slove();
    return 0;
}

```
