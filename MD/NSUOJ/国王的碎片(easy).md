# 国王的碎片（easy）

# 题目描述

在一个遥远的王国里，国王正面临一项艰巨的任务。这个王国世代以来依靠一块神圣石碑的庇佑，这块石碑蕴含着强大的神秘力量，保护着整个王国免受外敌侵袭。然而，不久前，一个恶魔趁着夜色突袭，摧毁了这块神圣石碑，将它打碎成了 $n$ 块。每一块碎片都蕴含着一种神秘的能量，这些能量共有$m$种不同的类型。石碑的破碎让王国陷入了前所未有的危机，各地的灾祸频繁，百姓们生活在恐惧之中。为了重铸石碑，恢复王国的安宁，国王需要召集一支小队，从这些散落的碎片中选取一段**连续**的碎片，使得这段碎片中恰好包含特定数量的每种能量。

具体而言，国王需要找到一段连续的碎片，使得其中包含第$1$种能量的碎片有$k_1$块，第$2$种能量的碎片有$k_2$块，以此类推，第$m$种能量的碎片有$k_m$块。每种能量都代表着王国的一部分力量，比如勇气、智慧、力量、仁爱等等，这些力量的平衡与和谐是石碑力量的源泉。国王深知，如果不能在最短的时间内找到这些碎片并重新拼接好石碑，整个王国将陷入更深的混乱，甚至有可能彻底覆灭。为了找到这一段完美匹配条件的碎片，国王发布了紧急命令，希望王国中最聪明、最勇敢的人们能够挺身而出，帮助他完成这项艰巨的任务。

国王的顾问们已经对碎片进行了分类和编号，但他们需要更精确的帮助来找到这一段**连续**的碎片。时间紧迫，恶魔的阴影已经开始笼罩王国，危机四伏。每当夜晚降临，恶魔的力量就会增强，带来更多的混乱和破坏，迫使百姓们不得不生活在恐惧之中。勇敢的战士们，王国的未来掌握在你们手中，能否帮助国王找到答案，拯救这个美丽的王国？找到这些碎片不仅仅是对智慧和勇气的考验，更是对忠诚和信仰的证明。每一个成功的尝试都将为王国带来希望，而每一次失败都会让王国离毁灭更近一步。你准备好迎接这个挑战了吗？

# 输入格式

第一行包含两个整数 $n$（$1 \le n \le 100$）和 $m$（$1 \le m \le n$），表示碎片的数量和能量类型的种类数。

第二行包含 $n$ 个整数，范围在 $1$ 至 $m$ 之间，表示每个碎片所蕴含的能量类型。

第三行包含 $m$ 个整数 $k_1,k_2,...,k_m$（$\displaystyle 1 \le \sum_{i = 1}^{m} k_i \le n$），表示每种能量类型所需的碎片数量。

# 输出格式

如果可以找到符合条件的连续碎片段，输出 $\texttt{YES}$，否则输出 $\texttt{NO}$。

### 样例输入 #1

```
5 2
1 1 2 2 1
1 2
```

### 样例输出 #1

```
YES
```

# 题解

对于n<100,直接暴力求解，找一个以$k_i$总和为区间长度的区间，将数统计完和所需的答案一致即可

```C++
#include <bits/stdc++.h>
#define int long long
#define endl "\n"
#define fs(x) std::fixed << std::setprecision(x)
const int N = 2e5 + 10;
const int mod = 1e9 + 7;
const int INF = INT64_MAX;
inline void slove()
{

    int n, m;
    std::cin >> n >> m;
    std::vector<int> a(n + 1), k(m + 1);
    for (int i = 1; i <= n; i++) std::cin >> a[i];
    for (int i = 1; i <= m; i++) std::cin >> k[i];
    int sum = 0;
    for (int i = 1; i <= m; i++) sum += k[i];
    bool ans = false;
    for (int i = 1; i <= n - sum + 1; i++)
    {
        std::map<int, int> mp;
        for (int j = i; j <= i + sum - 1; j++) mp[a[j]]++;
        bool flag = true;
        for (int j = 1; j <= m; j++)
        {
            if (mp[j] != k[j]) flag = false;
        }
        if (flag) ans = true;
    }
    if (ans)
        std::cout << "YES" << endl;
    else
        std::cout << "NO" << endl;
}
signed main()
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    int t = 1;
    // std::cin >> t;
    while (t--) slove();
    return 0;
}
```
